/**
 ******************************************************************************
 * @file     lib.c
 * @author   Auto-generated by STM32CubeIDE
 * @version  V1.0
 * @date     11/12/2024
 * @brief    Implementation of GSM_Module class for GSM communication.
 ******************************************************************************
 */

/*! \mainpage GSM Module Library for STM32F3DISCOVERY
 *
 * \section intro_sec Library Description
 *
 * Library simplifies GSM communication with STM32F3 microcontrollers.
 * It provides functions for making calls, sending and receiving SMS,
 * and retrieving date, time, and signal strength. The library
*  uses UART interrupts for efficient data handling and
 * includes error handling for reliable operation.
 */

#include "stm32f3xx_hal.h"
#include "GSMLibrary.hpp"
#include <cstring>
#include <string>
#include <utility>

/**
 * @brief Constructs a GSM_Module object and initializes communication.
 * @param[in] parameters Initialization parameters for the GSM module, including UART configuration.
 *
 * This constructor initializes the GSM module and sets it to text mode for SMS.
 * It also starts receiving data via UART interrupts.
 */
GSM_Module::GSM_Module(const Parameters& parameters) {
    gsm = this;
    this->parameters = parameters;
    if (!send_at_command(AT) || !send_at_command(MSG_TEXT_MODE)) {
        return;
    }
    start_receiving();
}

/**
 * @brief Initiates a call to the specified number.
 * @param[in] number The phone number to call.
 *
 * If the GSM module is in the IDLE state, this function sends the AT command
 * to initiate a call to the specified phone number.
 */
void GSM_Module::make_call(const char* number) {
    if (this->current_state != IDLE) {
        return;
    }

    char command[32];
    snprintf(command, sizeof(command), "%s%s;\r\n", CALL, number);
    transmit(command, strlen(command));

    this->prev_state = this->current_state;
    this->current_state = CALLING_PROCESS;
}

/**
 * @brief Answers an incoming call.
 *
 * Sends the "ATA" AT command to answer an incoming call.
 */
void GSM_Module::receive_call() {
    transmit("ATA\r\n", 5);
}

/**
 * @brief Ends the current call.
 *
 * Sends the "ATH" AT command to hang up the current call if the GSM module is
 * in the CALLING_PROCESS state.
 */
void GSM_Module::hang_up() {
    if (this->current_state != CALLING_PROCESS) {
        return;
    }

    transmit("ATH\r\n", 5);
    this->current_state = this->prev_state;
    this->prev_state = IDLE;
}

/**
 * @brief Sends an SMS to the specified number.
 * @param[in] number The recipient's phone number.
 * @param[in] message The SMS content.
 *
 * Sends an SMS by transmitting the AT command for SMS along with the message.
 * If the operation fails, it attempts to reset communication by making an empty call.
 */
void GSM_Module::send_sms(const char* number, const char* message) {
    char command[32];
    snprintf(command, sizeof(command), "%s\"%s\"\r", MSG, number);
    if (!transmit(command, strlen(command))) {
        make_call("");
    }
    HAL_Delay(1000);
    transmit(message, strlen(message));
    transmit(&END_OF_MSG, 1);
    HAL_Delay(1000);
}

/**
 * @brief Reads an SMS by its index.
 * @param[in] index The index of the SMS to read.
 * @return A pair containing the sender's number and the SMS content.
 *
 * Sends the AT command to read an SMS at the specified index and parses the response.
 * If the operation fails, it returns empty strings.
 */
std::pair<std::string, std::string> GSM_Module::read_sms(int index) {
    char command[32];
    snprintf(command, sizeof(command), "AT+CMGR=%d\r\n", index);

    if (!transmit(command, strlen(command))) {
        return {"", ""};
    }

    HAL_Delay(1000);
    return {this->sms_sender, this->sms_content};
}

/**
 * @brief Receives and parses SMS data from the GSM module.
 * @param[in] buffer The raw data buffer containing SMS information.
 *
 * Extracts the sender's number and message content from the buffer and
 * updates the `sms_sender` and `sms_content` attributes.
 */
void GSM_Module::receive_sms(std::string buffer) {
    size_t sender_start = buffer.find(",\"") + 2;
    size_t sender_end = buffer.find(",", sender_start);
    size_t message_start = buffer.find("\r\n", sender_end) + 2;
    size_t message_end = buffer.find("\r\n", message_start);
    if (sender_start != std::string::npos && sender_end != std::string::npos &&
        message_start != std::string::npos && message_end != std::string::npos) {
        this->sms_sender = buffer.substr(sender_start, sender_end - sender_start);
        this->sms_content = buffer.substr(message_start, message_end - message_start);
    }
}

/**
 * @brief Retrieves the current date and time from the GSM module.
 * @return A pair containing the date and time as strings.
 *
 * Sends the AT command to get the current date and time and parses the response.
 * If the operation fails, it returns empty strings.
 */
std::pair<std::string, std::string> GSM_Module::get_date_and_time() {
    if (!transmit(GET_TIME, strlen(GET_TIME))) {
        return {"", ""};
    }
    HAL_Delay(250);
    return {this->date, this->time};
}

/**
 * @brief Parses and updates the date and time information.
 * @param[in] buffer The raw data buffer containing date and time information.
 *
 * Extracts and processes the date and time from the buffer, adjusting for
 * time zone offsets and storing them as strings.
 */
void GSM_Module::receive_date_and_time(std::string buffer) {
    size_t cclk_start = buffer.find("+CCLK: ");

    if (cclk_start == std::string::npos) {
        return;
    }

    std::string time_string = buffer.substr(cclk_start + 7);

    if (time_string[0] == '"') {
        time_string = time_string.substr(1, time_string.size() - 2);
    }

    int year, month, day, hh, mm, ss, tz;

    if (sscanf(time_string.c_str(), "%2d/%2d/%2d,%2d:%2d:%2d+%2d", &year, &month, &day, &hh, &mm, &ss, &tz) != 7) {
        return;
    }

    hh += tz;

    if (hh >= 24) {
        day += 1;
        hh = hh % 24;
    }

    char date_buffer[9];
    snprintf(date_buffer, sizeof(date_buffer), "%02d/%02d/%02d", day, month, year);
    date = std::string(date_buffer);

    char time_buffer[9];
    snprintf(time_buffer, sizeof(time_buffer), "%02d:%02d:%02d", hh, mm, ss);
    time = std::string(time_buffer);
}

/**
 * @brief Retrieves the signal strength from the GSM module.
 * @return The signal strength (RSSI) as an integer, or -1 if retrieval fails.
 *
 * Sends the AT command to get the signal strength and parses the response.
 */
int GSM_Module::get_signal_strength() {
    if (!transmit(GET_SIGNAL, strlen(GET_SIGNAL))) {
        return -1;
    }
    HAL_Delay(250);
    return signal;
}

/**
 * @brief Parses and updates the signal strength.
 * @param[in] buffer The raw data buffer containing signal strength information.
 *
 * Extracts the RSSI value from the buffer and validates it. Updates the `signal`
 * attribute with the RSSI value.
 */
void GSM_Module::parse_signal_strength(std::string buffer) {
    size_t start = buffer.find("+CSQ: ");
    if (start == std::string::npos) {
        signal = -1;
        return;
    }

    std::string signal_data = buffer.substr(start + 6);
    int rssi;
    if (sscanf(signal_data.c_str(), "%d", &rssi) == 1) {
        signal = rssi;
    } else {
        signal = -1;
    }
}

/**
 * @brief Starts receiving data from the GSM module via UART.
 *
 * This function enables UART interrupts to receive data from the GSM module
 * and process incoming data as needed.
 */
void GSM_Module::start_receiving() {
    HAL_UART_Receive_IT(this->parameters.uart_handle, this->rx_buffer, sizeof(this->rx_buffer));
}

/**
 * @brief UART receive complete callback.
 * @param[in] huart UART handle for the callback.
 *
 * Handles the received data, parses responses, and invokes appropriate handlers
 * based on the context of the GSM module's operation.
 */
void GSM_Module::uart_receive_callback(UART_HandleTypeDef* huart) {
    if (huart->Instance == this->parameters.uart_handle->Instance) {
        // Process received data here
        std::string buffer(reinterpret_cast<char*>(this->rx_buffer), sizeof(this->rx_buffer));
        parse_response(buffer);
        HAL_UART_Receive_IT(this->parameters.uart_handle, this->rx_buffer, sizeof(this->rx_buffer));
    }
}

/**
 * @brief Transmits a command or data to the GSM module.
 * @param[in] data Pointer to the data to transmit.
 * @param[in] length Length of the data to transmit.
 * @return True if the transmission was successful, false otherwise.
 */
bool GSM_Module::transmit(const char* data, size_t length) {
    if (HAL_UART_Transmit(this->parameters.uart_handle, (uint8_t*)data, length, HAL_MAX_DELAY) == HAL_OK) {
        return true;
    }
    return false;
}

/**
 * @brief Sends an AT command to the GSM module and waits for a response.
 * @param[in] command The AT command to send.
 * @return True if the command was successful, false otherwise.
 */
bool GSM_Module::send_at_command(const char* command) {
    if (!transmit(command, strlen(command))) {
        return false;
    }
    HAL_Delay(100);
    // Add logic to verify response if needed
    return true;
}

/**
 * @brief Parses the response from the GSM module.
 * @param[in] buffer The raw response buffer to parse.
 *
 * Determines the type of response (e.g., SMS data, signal strength, date/time)
 * and invokes the appropriate handler.
 */
void GSM_Module::parse_response(std::string buffer) {
    if (buffer.find("+CMGR:") != std::string::npos) {
        receive_sms(buffer);
    } else if (buffer.find("+CSQ:") != std::string::npos) {
        parse_signal_strength(buffer);
    } else if (buffer.find("+CCLK:") != std::string::npos) {
        receive_date_and_time(buffer);
    }
}
